{
  "title": "Security & Secrets Management",
  "description": "70 questions couvrant tous les aspects de la sécurité et de la gestion des secrets : 20 questions de base sur les concepts fondamentaux et les bonnes pratiques, 35 questions intermédiaires sur Vault, le scanning, RBAC et les certificats, et 15 questions avancées sur l'architecture zero-trust, la compliance et l'automation avancée",
  "questions": [
    {
      "id": 1,
      "question": "Quel principe de sécurité stipule qu'un utilisateur ou processus ne doit avoir que les permissions minimales nécessaires ?",
      "options": [
        "Principle of Least Privilege",
        "Defense in Depth",
        "Zero Trust",
        "Separation of Duties"
      ],
      "answer": 0,
      "explanation": "Le Principle of Least Privilege (PoLP) est un concept fondamental en sécurité qui stipule qu'un compte utilisateur, processus ou système ne doit avoir accès qu'aux ressources strictement nécessaires pour accomplir sa fonction légitime.",
      "difficulty": "easy"
    },
    {
      "id": 2,
      "question": "Qu'est-ce que la 'Defense in Depth' en sécurité ?",
      "options": [
        "Une seule couche de sécurité très robuste",
        "Plusieurs couches de sécurité successives",
        "La sécurité au niveau du réseau uniquement",
        "Un système de backup profond"
      ],
      "answer": 1,
      "explanation": "Defense in Depth est une stratégie de sécurité qui utilise plusieurs couches de contrôles de sécurité. Si une couche échoue, les autres continuent de protéger le système. C'est comme avoir plusieurs portes verrouillées au lieu d'une seule.",
      "difficulty": "easy"
    },
    {
      "id": 3,
      "question": "Que signifie 'Shift-Left Security' dans le contexte DevSecOps ?",
      "options": [
        "Déplacer les serveurs de sécurité vers la gauche du datacenter",
        "Intégrer la sécurité le plus tôt possible dans le cycle de développement",
        "Utiliser uniquement des outils open-source",
        "Sécuriser uniquement la phase de production"
      ],
      "answer": 1,
      "explanation": "Shift-Left Security signifie intégrer les pratiques de sécurité dès les premières phases du développement (à gauche dans un diagramme de cycle de vie), plutôt que d'attendre la fin. Cela permet de détecter et corriger les vulnérabilités plus tôt et à moindre coût.",
      "difficulty": "easy"
    },
    {
      "id": 4,
      "question": "Quelle est la principale différence entre DevOps et DevSecOps ?",
      "options": [
        "DevSecOps est plus lent",
        "DevSecOps intègre la sécurité comme responsabilité partagée tout au long du cycle",
        "DevSecOps ne nécessite pas d'automatisation",
        "DevSecOps est uniquement pour les grandes entreprises"
      ],
      "answer": 1,
      "explanation": "DevSecOps étend DevOps en intégrant la sécurité comme une responsabilité partagée tout au long du cycle de développement et de déploiement, plutôt que comme une phase séparée en fin de processus.",
      "difficulty": "easy"
    },
    {
      "id": 5,
      "question": "Que représente la triade CIA en sécurité informatique ?",
      "options": [
        "Central Intelligence Agency",
        "Confidentiality, Integrity, Availability",
        "Container, Image, Application",
        "Crypto, Infrastructure, Authentication"
      ],
      "answer": 1,
      "explanation": "La triade CIA représente les trois piliers fondamentaux de la sécurité : Confidentiality (confidentialité des données), Integrity (intégrité des données), et Availability (disponibilité des systèmes).",
      "difficulty": "easy"
    },
    {
      "id": 6,
      "question": "Qu'est-ce que l'Attack Surface d'une application ?",
      "options": [
        "La surface physique des serveurs",
        "L'ensemble des points d'entrée potentiels pour un attaquant",
        "La taille du code source",
        "Le nombre d'utilisateurs de l'application"
      ],
      "answer": 1,
      "explanation": "L'Attack Surface représente l'ensemble des points d'entrée, interfaces et vulnérabilités potentielles qu'un attaquant pourrait exploiter. Réduire cette surface est une bonne pratique de sécurité.",
      "difficulty": "easy"
    },
    {
      "id": 7,
      "question": "Qu'est-ce qu'un 'secret' dans le contexte DevOps ?",
      "options": [
        "Uniquement les mots de passe utilisateurs",
        "Toute information sensible (passwords, API keys, tokens, certificates)",
        "Les fichiers de configuration",
        "Les logs d'application"
      ],
      "answer": 1,
      "explanation": "Un secret est toute information sensible qui doit être protégée : mots de passe, clés API, tokens d'accès, certificats, clés de chiffrement, chaînes de connexion à des bases de données, etc.",
      "difficulty": "easy"
    },
    {
      "id": 8,
      "question": "Pourquoi ne faut-il JAMAIS commiter des secrets dans Git ?",
      "options": [
        "Cela ralentit Git",
        "L'historique Git est permanent et difficile à nettoyer, exposant les secrets",
        "Git ne supporte pas les secrets",
        "C'est juste une recommandation, pas une obligation"
      ],
      "answer": 1,
      "explanation": "L'historique Git est permanent et distribué. Une fois un secret commité, il reste dans l'historique même après suppression. Il peut être découvert par des attaquants qui scannent les repos publics ou compromettent le repo.",
      "difficulty": "easy"
    },
    {
      "id": 9,
      "question": "Quelle est la meilleure pratique pour gérer des secrets en développement local ?",
      "options": [
        "Les hardcoder dans le code source",
        "Utiliser des fichiers .env avec .gitignore",
        "Les partager par email",
        "Les stocker dans des commentaires du code"
      ],
      "answer": 1,
      "explanation": "Les fichiers .env permettent de stocker les secrets localement tout en les excluant du contrôle de version via .gitignore. C'est une pratique courante et sûre pour le développement local.",
      "difficulty": "easy"
    },
    {
      "id": 10,
      "question": "Quelle est la différence entre un secret et une configuration ?",
      "options": [
        "Il n'y a pas de différence",
        "Un secret est sensible et doit être chiffré, une configuration est publique",
        "Les configurations sont plus importantes",
        "Les secrets sont toujours dans le cloud"
      ],
      "answer": 1,
      "explanation": "Un secret contient des informations sensibles qui doivent être protégées (ex: mot de passe DB), tandis qu'une configuration contient des paramètres non sensibles (ex: timeout, log level) qui peuvent être versionnés publiquement.",
      "difficulty": "easy"
    },
    {
      "id": 11,
      "question": "Qu'est-ce que le 'Secret Sprawl' ?",
      "options": [
        "Un algorithme de chiffrement",
        "La prolifération incontrôlée de secrets dans différents systèmes",
        "Un type d'attaque",
        "Un outil de gestion de secrets"
      ],
      "answer": 1,
      "explanation": "Le Secret Sprawl désigne la prolifération des secrets (clés API, mots de passe, tokens) à travers différents systèmes, fichiers, wikis et outils, rendant leur gestion et rotation difficiles.",
      "difficulty": "easy"
    },
    {
      "id": 12,
      "question": "Qu'est-ce que la rotation des credentials ?",
      "options": [
        "Changer régulièrement les secrets pour limiter l'exposition",
        "Faire tourner les serveurs",
        "Déplacer les secrets d'un système à l'autre",
        "Archiver les anciens secrets"
      ],
      "answer": 0,
      "explanation": "La rotation des credentials consiste à changer régulièrement les secrets (mots de passe, clés API, certificats) pour limiter la fenêtre d'exposition en cas de compromission.",
      "difficulty": "easy"
    },
    {
      "id": 13,
      "question": "Pourquoi est-il important de séparer les secrets entre dev, staging et production ?",
      "options": [
        "Pour économiser de l'argent",
        "Pour limiter l'impact d'une compromission et respecter le principe de moindre privilège",
        "C'est juste une recommandation optionnelle",
        "Pour faciliter les tests"
      ],
      "answer": 1,
      "explanation": "Séparer les secrets par environnement limite l'impact d'une compromission (ex: un secret dev compromis n'expose pas la prod) et applique le principe de moindre privilège.",
      "difficulty": "easy"
    },
    {
      "id": 14,
      "question": "Qu'est-ce que MFA/2FA et pourquoi est-ce important ?",
      "options": [
        "Multi-Factor Authentication - ajoute une couche de sécurité au-delà du mot de passe",
        "Un protocole de chiffrement",
        "Un type de base de données",
        "Un framework de sécurité"
      ],
      "answer": 0,
      "explanation": "MFA (Multi-Factor Authentication) ou 2FA (Two-Factor Authentication) nécessite au moins deux méthodes de vérification (ex: mot de passe + code SMS), réduisant drastiquement les risques de compromission.",
      "difficulty": "easy"
    },
    {
      "id": 15,
      "question": "Pourquoi faut-il utiliser des password managers ?",
      "options": [
        "Pour partager les mots de passe facilement",
        "Pour générer et stocker des mots de passe forts et uniques de manière sécurisée",
        "Pour se souvenir des URLs",
        "C'est juste une mode"
      ],
      "answer": 1,
      "explanation": "Les password managers génèrent des mots de passe forts et uniques pour chaque service, les stockent de manière chiffrée, et permettent d'éviter la réutilisation de mots de passe faibles.",
      "difficulty": "easy"
    },
    {
      "id": 16,
      "question": "Pourquoi faut-il toujours utiliser HTTPS/TLS plutôt que HTTP ?",
      "options": [
        "C'est plus rapide",
        "Cela chiffre les communications et protège contre l'interception",
        "C'est requis uniquement pour les sites e-commerce",
        "Pour améliorer le SEO uniquement"
      ],
      "answer": 1,
      "explanation": "HTTPS/TLS chiffre les communications entre le client et le serveur, protégeant contre l'interception, la modification des données (man-in-the-middle) et garantissant l'authenticité du serveur.",
      "difficulty": "easy"
    },
    {
      "id": 17,
      "question": "Quelle est la différence entre Authentication et Authorization ?",
      "options": [
        "Il n'y a pas de différence",
        "Authentication = qui êtes-vous, Authorization = que pouvez-vous faire",
        "Authorization vient avant Authentication",
        "Authentication est plus important"
      ],
      "answer": 1,
      "explanation": "Authentication (AuthN) vérifie l'identité de l'utilisateur (qui êtes-vous ?), tandis qu'Authorization (AuthZ) détermine ce que l'utilisateur authentifié est autorisé à faire (quels sont vos droits ?).",
      "difficulty": "easy"
    },
    {
      "id": 18,
      "question": "Qu'est-ce qu'un JWT (JSON Web Token) ?",
      "options": [
        "Un format de base de données",
        "Un standard de token pour transmettre des informations de manière sécurisée",
        "Un protocole réseau",
        "Un algorithme de chiffrement"
      ],
      "answer": 1,
      "explanation": "JWT est un standard ouvert (RFC 7519) qui définit un format compact et autosuffisant pour transmettre des informations de manière sécurisée entre parties sous forme d'objet JSON signé.",
      "difficulty": "easy"
    },
    {
      "id": 19,
      "question": "Quelle est la différence entre un service account et un user account ?",
      "options": [
        "Il n'y a pas de différence",
        "Un service account est pour les applications/processus, un user account pour les humains",
        "Un service account est plus sécurisé",
        "Un user account ne peut pas avoir de permissions"
      ],
      "answer": 1,
      "explanation": "Un service account est une identité pour les applications, services ou processus automatisés, tandis qu'un user account est pour les utilisateurs humains. Les service accounts ne doivent généralement pas avoir de mot de passe interactif.",
      "difficulty": "easy"
    },
    {
      "id": 20,
      "question": "Qu'est-ce qu'une API key et quand l'utiliser ?",
      "options": [
        "Un mot de passe complexe",
        "Un token d'identification pour l'accès programmatique aux APIs",
        "Une clé de chiffrement",
        "Un certificat SSL"
      ],
      "answer": 1,
      "explanation": "Une API key est un token unique utilisé pour authentifier les requêtes vers une API. Elle identifie l'application ou le projet appelant et permet de contrôler l'accès et les quotas.",
      "difficulty": "easy"
    },
    {
      "id": 21,
      "question": "Quels sont les composants principaux de l'architecture HashiCorp Vault ?",
      "options": [
        "Client, Database, Cache",
        "Vault Server, Storage Backend, Seal/Unseal Mechanism",
        "Frontend, Backend, API",
        "Master, Worker, Agent"
      ],
      "answer": 1,
      "explanation": "Vault se compose d'un serveur Vault, d'un storage backend (pour persister les données chiffrées), et d'un mécanisme de seal/unseal qui protège les données au repos avec une master key.",
      "difficulty": "intermediate"
    },
    {
      "id": 22,
      "question": "Qu'est-ce qu'un Secrets Engine dans HashiCorp Vault ?",
      "options": [
        "Un algorithme de chiffrement",
        "Un composant qui stocke, génère ou chiffre des secrets",
        "Un type de base de données",
        "Un protocole réseau"
      ],
      "answer": 1,
      "explanation": "Un Secrets Engine est un composant Vault qui stocke, génère ou chiffre des données. Différents engines ont des comportements différents : KV stocke des secrets statiques, Database génère des credentials dynamiques, etc.",
      "difficulty": "intermediate"
    },
    {
      "id": 23,
      "question": "Quels sont les principaux Secrets Engines de Vault ?",
      "options": [
        "MySQL, PostgreSQL, MongoDB",
        "KV, Database, PKI, AWS, Transit, SSH",
        "S3, EC2, Lambda",
        "Docker, Kubernetes, Terraform"
      ],
      "answer": 1,
      "explanation": "Les principaux Secrets Engines incluent : KV (key-value), Database (credentials dynamiques), PKI (certificats), AWS/Azure/GCP (credentials cloud), Transit (chiffrement as-a-service), SSH (certificats SSH).",
      "difficulty": "intermediate"
    },
    {
      "id": 24,
      "question": "Quelle est la différence entre KV v1 et KV v2 dans Vault ?",
      "options": [
        "KV v2 est plus rapide",
        "KV v2 supporte le versioning et le soft delete, pas v1",
        "KV v1 est plus sécurisé",
        "Il n'y a pas de différence"
      ],
      "answer": 1,
      "explanation": "KV v2 ajoute le versioning automatique des secrets (historique des versions), le soft delete (récupération possible), et des métadonnées supplémentaires. KV v1 n'offre qu'un stockage simple clé-valeur.",
      "difficulty": "intermediate"
    },
    {
      "id": 25,
      "question": "Qu'est-ce qu'une méthode d'authentification (Auth Method) dans Vault ?",
      "options": [
        "Un algorithme de chiffrement",
        "Un mécanisme pour vérifier l'identité et obtenir un token Vault",
        "Un type de secret",
        "Un protocole réseau"
      ],
      "answer": 1,
      "explanation": "Une Auth Method est un plugin qui permet à un utilisateur, application ou service de s'authentifier auprès de Vault et d'obtenir un token avec des permissions spécifiques.",
      "difficulty": "intermediate"
    },
    {
      "id": 26,
      "question": "Quelles sont les méthodes d'authentification courantes dans Vault ?",
      "options": [
        "FTP, SMTP, HTTP",
        "Token, AppRole, Kubernetes, AWS IAM, LDAP, GitHub",
        "SSH, Telnet, RDP",
        "REST, GraphQL, SOAP"
      ],
      "answer": 1,
      "explanation": "Les méthodes courantes incluent : Token (direct), AppRole (pour apps), Kubernetes (pour pods), AWS IAM (pour instances EC2), Azure MSI, LDAP, GitHub, et bien d'autres.",
      "difficulty": "intermediate"
    },
    {
      "id": 27,
      "question": "Qu'est-ce qu'AppRole dans Vault et quand l'utiliser ?",
      "options": [
        "Un rôle pour les utilisateurs",
        "Une méthode d'authentification pour les applications automatisées",
        "Un type de secret",
        "Un plugin Vault"
      ],
      "answer": 1,
      "explanation": "AppRole est une méthode d'authentification conçue pour les applications et services automatisés. Elle utilise un RoleID (public) et un SecretID (secret) pour authentifier l'application et obtenir un token.",
      "difficulty": "intermediate"
    },
    {
      "id": 28,
      "question": "Qu'est-ce qu'une Policy dans HashiCorp Vault ?",
      "options": [
        "Un type de secret",
        "Une règle HCL définissant les permissions d'accès aux secrets",
        "Un algorithme de chiffrement",
        "Un composant d'infrastructure"
      ],
      "answer": 1,
      "explanation": "Une Policy Vault est un document HCL (ou JSON) qui définit les permissions (capabilities) sur des chemins spécifiques. Elle contrôle qui peut lire, écrire, lister ou supprimer des secrets.",
      "difficulty": "intermediate"
    },
    {
      "id": 29,
      "question": "Quelles sont les capabilities disponibles dans une Vault Policy ?",
      "options": [
        "read, write, delete",
        "create, read, update, delete, list, sudo, deny",
        "get, put, post",
        "select, insert, update"
      ],
      "answer": 1,
      "explanation": "Les capabilities Vault sont : create, read, update, delete, list (lister les clés), sudo (accès root sur un chemin), et deny (refus explicite).",
      "difficulty": "intermediate"
    },
    {
      "id": 30,
      "question": "Qu'est-ce qu'un Dynamic Secret dans Vault ?",
      "options": [
        "Un secret qui change aléatoirement",
        "Un credential généré à la demande avec un TTL et révoqué automatiquement",
        "Un secret stocké dynamiquement",
        "Un type de chiffrement"
      ],
      "answer": 1,
      "explanation": "Un Dynamic Secret est un credential généré par Vault à la demande (ex: user/password MySQL), avec un Time-To-Live limité, et automatiquement révoqué à l'expiration. Cela réduit l'exposition des credentials.",
      "difficulty": "intermediate"
    },
    {
      "id": 31,
      "question": "Qu'est-ce qu'un Lease dans Vault ?",
      "options": [
        "Un contrat de location de serveur",
        "Une période de validité associée à un secret avec possibilité de renewal",
        "Un type de stockage",
        "Un protocole de communication"
      ],
      "answer": 1,
      "explanation": "Un Lease est une durée de vie (TTL) associée à un secret dynamique. Il peut être renouvelé (renewal) avant expiration ou révoqué manuellement. À l'expiration, le secret est automatiquement révoqué.",
      "difficulty": "intermediate"
    },
    {
      "id": 32,
      "question": "Qu'est-ce que Vault Agent et à quoi sert-il ?",
      "options": [
        "Un outil de monitoring",
        "Un daemon qui gère l'auto-auth, le caching et le templating de secrets",
        "Un type de secret",
        "Un protocole réseau"
      ],
      "answer": 1,
      "explanation": "Vault Agent est un daemon qui s'exécute sur le client, gère l'auto-authentication auprès de Vault, cache les tokens, et peut utiliser des templates pour injecter des secrets dans des fichiers de configuration.",
      "difficulty": "intermediate"
    },
    {
      "id": 33,
      "question": "Qu'est-ce que le Vault Injector pour Kubernetes ?",
      "options": [
        "Un outil de déploiement",
        "Un mutating webhook qui injecte automatiquement les secrets Vault dans les pods",
        "Un type de service",
        "Un plugin de monitoring"
      ],
      "answer": 1,
      "explanation": "Le Vault Injector (ou Vault Agent Injector) est un mutating admission webhook Kubernetes qui intercepte les pods, injecte un Vault Agent sidecar, et monte automatiquement les secrets dans le pod.",
      "difficulty": "intermediate"
    },
    {
      "id": 34,
      "question": "Qu'est-ce que le processus Seal/Unseal dans Vault ?",
      "options": [
        "Le démarrage/arrêt du serveur",
        "Le chiffrement/déchiffrement de la master key pour protéger les données au repos",
        "La création de backups",
        "La rotation des secrets"
      ],
      "answer": 1,
      "explanation": "Sealed : Vault est démarré mais ne peut pas déchiffrer les données (master key chiffrée). Unsealed : après avoir fourni les unseal keys (Shamir shares), Vault reconstruit la master key et peut déchiffrer les données.",
      "difficulty": "intermediate"
    },
    {
      "id": 35,
      "question": "Quels sont les storage backends supportés par Vault ?",
      "options": [
        "MySQL, PostgreSQL uniquement",
        "Consul, etcd, Raft, DynamoDB, S3, Filesystem, et bien d'autres",
        "Redis uniquement",
        "MongoDB uniquement"
      ],
      "answer": 1,
      "explanation": "Vault supporte de nombreux storage backends : Integrated Storage (Raft), Consul, etcd, DynamoDB, Azure Storage, GCS, S3, Filesystem, etc. Le choix dépend des besoins de HA et performance.",
      "difficulty": "intermediate"
    },
    {
      "id": 36,
      "question": "Quelle est la différence entre AWS Secrets Manager et Parameter Store ?",
      "options": [
        "Il n'y a pas de différence",
        "Secrets Manager offre la rotation automatique et le versioning, Parameter Store est plus simple et moins cher",
        "Parameter Store est plus sécurisé",
        "Secrets Manager ne supporte pas le chiffrement"
      ],
      "answer": 1,
      "explanation": "Secrets Manager est spécialisé pour les secrets avec rotation automatique intégrée, versioning, et politique de rotation. Parameter Store est plus générique, moins cher, mais nécessite une gestion manuelle de la rotation.",
      "difficulty": "intermediate"
    },
    {
      "id": 37,
      "question": "Qu'est-ce qu'Azure Key Vault et que peut-il stocker ?",
      "options": [
        "Uniquement des mots de passe",
        "Secrets, Keys (cryptographic), et Certificates",
        "Uniquement des fichiers",
        "Uniquement des configurations"
      ],
      "answer": 1,
      "explanation": "Azure Key Vault peut stocker trois types d'objets : Secrets (chaînes sensibles), Keys (clés cryptographiques avec HSM option), et Certificates (certificats X.509 avec gestion du lifecycle).",
      "difficulty": "intermediate"
    },
    {
      "id": 38,
      "question": "Comment GCP Secret Manager gère-t-il le versioning des secrets ?",
      "options": [
        "Pas de versioning",
        "Versioning automatique avec possibilité d'accéder aux versions précédentes",
        "Seulement la dernière version",
        "Versioning manuel uniquement"
      ],
      "answer": 1,
      "explanation": "GCP Secret Manager maintient automatiquement toutes les versions d'un secret. Chaque modification crée une nouvelle version, et vous pouvez accéder à n'importe quelle version via son numéro ou utiliser 'latest'.",
      "difficulty": "intermediate"
    },
    {
      "id": 39,
      "question": "Comment intégrer IAM avec les secrets managers cloud ?",
      "options": [
        "Ce n'est pas possible",
        "Utiliser les policies IAM pour contrôler l'accès aux secrets (principe de moindre privilège)",
        "Tous les utilisateurs ont accès à tous les secrets",
        "Utiliser uniquement des mots de passe"
      ],
      "answer": 1,
      "explanation": "Les secrets managers cloud (AWS, Azure, GCP) s'intègrent nativement avec leurs systèmes IAM respectifs. On définit des policies IAM pour contrôler précisément qui (user, role, service) peut accéder à quels secrets.",
      "difficulty": "intermediate"
    },
    {
      "id": 40,
      "question": "Quelle est la différence entre encryption at rest et in transit ?",
      "options": [
        "Il n'y a pas de différence",
        "At rest = données stockées chiffrées, In transit = communications réseau chiffrées",
        "At rest est plus important",
        "In transit est optionnel"
      ],
      "answer": 1,
      "explanation": "Encryption at rest protège les données stockées sur disque (databases, backups, storage). Encryption in transit protège les données pendant leur transmission sur le réseau (TLS/SSL). Les deux sont essentiels.",
      "difficulty": "intermediate"
    },
    {
      "id": 41,
      "question": "Pourquoi le versioning des secrets est-il important ?",
      "options": [
        "Pour économiser de l'espace",
        "Pour pouvoir rollback en cas de problème et auditer les changements",
        "Ce n'est pas important",
        "Uniquement pour la compliance"
      ],
      "answer": 1,
      "explanation": "Le versioning permet de revenir à une version précédente en cas de problème (rollback), d'auditer qui a changé quoi et quand, et de maintenir plusieurs versions actives pendant une période de transition.",
      "difficulty": "intermediate"
    },
    {
      "id": 42,
      "question": "Comment créer un Kubernetes Secret de type Opaque ?",
      "options": [
        "kubectl create secret docker-registry",
        "kubectl create secret generic <name> --from-literal=key=value",
        "kubectl create secret tls",
        "kubectl create configmap"
      ],
      "answer": 1,
      "explanation": "Un Secret Opaque (type par défaut) est créé avec 'kubectl create secret generic' en utilisant --from-literal, --from-file, ou --from-env-file pour spécifier les données.",
      "difficulty": "intermediate"
    },
    {
      "id": 43,
      "question": "Les Kubernetes Secrets sont-ils chiffrés par défaut ?",
      "options": [
        "Oui, toujours chiffrés",
        "Non, seulement encodés en Base64 par défaut (pas de chiffrement)",
        "Chiffrés uniquement en production",
        "Dépend de la version de Kubernetes"
      ],
      "answer": 1,
      "explanation": "Par défaut, les Kubernetes Secrets sont seulement encodés en Base64, PAS chiffrés. Base64 est facilement décodable. Pour un vrai chiffrement, il faut activer Encryption at Rest avec EncryptionConfiguration.",
      "difficulty": "intermediate"
    },
    {
      "id": 44,
      "question": "Comment activer le chiffrement at rest des Secrets dans Kubernetes ?",
      "options": [
        "C'est automatique",
        "Configurer EncryptionConfiguration sur l'API server avec un provider (aescbc, kms, etc.)",
        "Utiliser un plugin",
        "Ce n'est pas possible"
      ],
      "answer": 1,
      "explanation": "On configure le kube-apiserver avec --encryption-provider-config pointant vers un fichier EncryptionConfiguration qui définit les providers de chiffrement (aescbc, aesgcm, secretbox, kms).",
      "difficulty": "intermediate"
    },
    {
      "id": 45,
      "question": "Qu'est-ce que l'External Secrets Operator pour Kubernetes ?",
      "options": [
        "Un outil de backup",
        "Un opérateur qui synchronise les secrets depuis des systèmes externes (Vault, AWS, Azure, etc.) vers K8s",
        "Un plugin de monitoring",
        "Un outil de déploiement"
      ],
      "answer": 1,
      "explanation": "External Secrets Operator synchronise automatiquement les secrets depuis des systèmes externes (Vault, AWS Secrets Manager, Azure Key Vault, GCP Secret Manager) vers des Secrets Kubernetes natifs.",
      "difficulty": "intermediate"
    },
    {
      "id": 46,
      "question": "Qu'est-ce que Sealed Secrets de Bitnami ?",
      "options": [
        "Un type de pod",
        "Un système pour chiffrer les Secrets K8s et les stocker en toute sécurité dans Git",
        "Un outil de backup",
        "Un protocole réseau"
      ],
      "answer": 1,
      "explanation": "Sealed Secrets permet de chiffrer les Secrets avec une clé publique, créant un SealedSecret qui peut être commité dans Git. Le controller cluster déchiffre et crée le Secret natif.",
      "difficulty": "intermediate"
    },
    {
      "id": 47,
      "question": "Qu'est-ce que le CSI Secret Store Driver ?",
      "options": [
        "Un type de volume",
        "Une interface permettant de monter des secrets depuis des stores externes directement dans les pods",
        "Un plugin réseau",
        "Un outil de monitoring"
      ],
      "answer": 1,
      "explanation": "Le Secret Store CSI Driver utilise l'interface CSI pour monter des secrets depuis des providers externes (Vault, Azure Key Vault, AWS Secrets Manager) directement comme des volumes dans les pods.",
      "difficulty": "intermediate"
    },
    {
      "id": 48,
      "question": "Qu'est-ce que Trivy et à quoi sert-il ?",
      "options": [
        "Un orchestrateur",
        "Un scanner de vulnérabilités pour containers, IaC, filesystems, Git repos",
        "Un outil de déploiement",
        "Un système de logging"
      ],
      "answer": 1,
      "explanation": "Trivy est un scanner de sécurité open-source qui détecte les vulnérabilités dans les images containers, les dépendances (SCA), le code IaC (Terraform, K8s), et les configurations.",
      "difficulty": "intermediate"
    },
    {
      "id": 49,
      "question": "Quelle est la différence entre SAST et DAST ?",
      "options": [
        "Il n'y a pas de différence",
        "SAST analyse le code source (static), DAST teste l'application en cours d'exécution (dynamic)",
        "DAST est plus rapide",
        "SAST est uniquement pour les images"
      ],
      "answer": 1,
      "explanation": "SAST (Static Application Security Testing) analyse le code source sans l'exécuter. DAST (Dynamic Application Security Testing) teste l'application en cours d'exécution en simulant des attaques.",
      "difficulty": "intermediate"
    },
    {
      "id": 50,
      "question": "Qu'est-ce que SCA (Software Composition Analysis) ?",
      "options": [
        "Un langage de programmation",
        "L'analyse des dépendances open-source pour détecter les vulnérabilités connues",
        "Un type de test",
        "Un protocole de sécurité"
      ],
      "answer": 1,
      "explanation": "SCA analyse les composants et dépendances open-source d'une application (libraries, packages) pour identifier les vulnérabilités connues, les licences, et les versions obsolètes.",
      "difficulty": "intermediate"
    },
    {
      "id": 51,
      "question": "Qu'est-ce qu'un CVE ?",
      "options": [
        "Un type de certificat",
        "Common Vulnerabilities and Exposures - identifiant unique pour une vulnérabilité connue",
        "Un algorithme de chiffrement",
        "Un protocole réseau"
      ],
      "answer": 1,
      "explanation": "CVE (Common Vulnerabilities and Exposures) est un identifiant standardisé unique (ex: CVE-2021-44228) pour une vulnérabilité de sécurité publiquement connue, maintenu par MITRE.",
      "difficulty": "intermediate"
    },
    {
      "id": 52,
      "question": "Comment interpréter un score CVSS ?",
      "options": [
        "Plus c'est élevé, mieux c'est",
        "Score de 0-10 indiquant la sévérité (0=None, 0.1-3.9=Low, 4-6.9=Medium, 7-8.9=High, 9-10=Critical)",
        "C'est un pourcentage",
        "C'est une note alphabétique"
      ],
      "answer": 1,
      "explanation": "CVSS (Common Vulnerability Scoring System) note de 0 à 10 la sévérité d'une vulnérabilité. Plus le score est élevé, plus la vulnérabilité est critique et doit être traitée en priorité.",
      "difficulty": "intermediate"
    },
    {
      "id": 53,
      "question": "Qu'est-ce qu'un workflow typique de vulnerability management ?",
      "options": [
        "Scanner, Ignorer, Continuer",
        "Découverte, Priorisation, Remediation, Vérification, Reporting",
        "Déployer, Tester, Approuver",
        "Développer, Compiler, Déployer"
      ],
      "answer": 1,
      "explanation": "Le cycle typique : 1) Découverte (scanning), 2) Priorisation (par CVSS et criticité), 3) Remediation (patch/mitigation), 4) Vérification (re-scan), 5) Reporting et métriques.",
      "difficulty": "intermediate"
    },
    {
      "id": 54,
      "question": "Qu'est-ce que RBAC (Role-Based Access Control) ?",
      "options": [
        "Un protocole réseau",
        "Un modèle de contrôle d'accès basé sur les rôles plutôt que sur les utilisateurs individuels",
        "Un type de base de données",
        "Un algorithme de chiffrement"
      ],
      "answer": 1,
      "explanation": "RBAC associe des permissions à des rôles, puis assigne des rôles aux utilisateurs. Au lieu de gérer les permissions individuellement, on gère les rôles, simplifiant l'administration.",
      "difficulty": "intermediate"
    },
    {
      "id": 55,
      "question": "Quelles sont les ressources principales de Kubernetes RBAC ?",
      "options": [
        "User, Group, Password",
        "Role, ClusterRole, RoleBinding, ClusterRoleBinding",
        "Pod, Service, Deployment",
        "Secret, ConfigMap, Volume"
      ],
      "answer": 1,
      "explanation": "RBAC K8s utilise : Role (permissions namespace), ClusterRole (permissions cluster-wide), RoleBinding (lie un Role à des sujets), ClusterRoleBinding (lie un ClusterRole à des sujets).",
      "difficulty": "intermediate"
    },
    {
      "id": 56,
      "question": "Qu'est-ce que mTLS (mutual TLS) et pourquoi est-ce important dans Zero Trust ?",
      "options": [
        "TLS avec plusieurs certificats",
        "Authentification bidirectionnelle où client ET serveur s'authentifient mutuellement via certificats",
        "TLS plus rapide",
        "TLS pour mobile uniquement"
      ],
      "answer": 1,
      "explanation": "mTLS (mutual TLS) authentifie les deux parties : le serveur présente son certificat au client (TLS classique) ET le client présente son certificat au serveur. Essentiel pour Zero Trust service-to-service.",
      "difficulty": "advanced"
    },
    {
      "id": 57,
      "question": "Quels sont les principes fondamentaux du Zero Trust ?",
      "options": [
        "Faire confiance au réseau interne",
        "Never trust, always verify - vérifier explicitement chaque requête indépendamment de la source",
        "Utiliser uniquement des firewalls",
        "La sécurité périmétrique est suffisante"
      ],
      "answer": 1,
      "explanation": "Zero Trust repose sur 'never trust, always verify' : aucune confiance implicite basée sur la localisation réseau. Chaque accès est vérifié explicitement (identity, device, context) à chaque requête.",
      "difficulty": "advanced"
    },
    {
      "id": 58,
      "question": "Quelle est la différence entre identity-based et network-based security ?",
      "options": [
        "Il n'y a pas de différence",
        "Identity-based vérifie qui/quoi fait la requête, network-based vérifie d'où vient la requête",
        "Network-based est plus sécurisé",
        "Identity-based est obsolète"
      ],
      "answer": 1,
      "explanation": "Network-based security (firewalls, VLANs) contrôle l'accès basé sur l'IP/réseau source. Identity-based security (Zero Trust) contrôle basé sur l'identité vérifiée (user, service) indépendamment du réseau.",
      "difficulty": "advanced"
    },
    {
      "id": 59,
      "question": "Qu'est-ce que le modèle BeyondCorp de Google ?",
      "options": [
        "Un produit Google",
        "Un modèle Zero Trust où l'accès est basé sur l'identité/device, pas sur le réseau d'entreprise",
        "Un protocole réseau",
        "Un framework de développement"
      ],
      "answer": 1,
      "explanation": "BeyondCorp est l'implémentation Zero Trust de Google : accès basé sur l'identité et le contexte de l'appareil, pas sur la connexion au réseau corporate. Les employés accèdent aux ressources comme s'ils étaient sur Internet.",
      "difficulty": "advanced"
    },
    {
      "id": 60,
      "question": "Comment configurer Vault en High Availability avec Raft ?",
      "options": [
        "Un seul serveur suffit",
        "Minimum 3 nœuds Vault utilisant Integrated Storage (Raft) pour le consensus et la réplication",
        "Utiliser un load balancer uniquement",
        "Ce n'est pas possible"
      ],
      "answer": 1,
      "explanation": "Vault HA avec Raft (Integrated Storage) nécessite au moins 3 nœuds (recommandé 5) qui forment un cluster avec élection de leader via consensus Raft. Offre HA sans dépendance externe.",
      "difficulty": "advanced"
    },
    {
      "id": 61,
      "question": "Quelle est la différence entre Performance Replication et Disaster Recovery dans Vault Enterprise ?",
      "options": [
        "Il n'y a pas de différence",
        "Performance = réplication active pour scale en lecture, DR = standby pour failover",
        "DR est plus rapide",
        "Performance est uniquement pour la prod"
      ],
      "answer": 1,
      "explanation": "Performance Replication réplique les données pour permettre des lectures locales dans différentes régions (scaling). DR Replication crée un cluster standby passif pour le failover en cas de désastre du cluster primaire.",
      "difficulty": "advanced"
    },
    {
      "id": 62,
      "question": "Qu'est-ce que les Vault Namespaces (Enterprise) ?",
      "options": [
        "Des namespaces Kubernetes",
        "Une isolation logique permettant de créer des environnements Vault isolés dans un seul cluster",
        "Un type de secret",
        "Un protocole réseau"
      ],
      "answer": 1,
      "explanation": "Les Namespaces Vault (feature Enterprise) permettent d'isoler complètement des tenants/équipes dans un seul cluster Vault : auth methods, secrets engines, policies séparés, avec gestion déléguée.",
      "difficulty": "advanced"
    },
    {
      "id": 63,
      "question": "Qu'est-ce que OPA (Open Policy Agent) ?",
      "options": [
        "Un outil de monitoring",
        "Un moteur de policy-as-code général utilisant le langage Rego pour appliquer des règles",
        "Un protocole réseau",
        "Un type de base de données"
      ],
      "answer": 1,
      "explanation": "OPA est un moteur de policy open-source, agnostique du domaine, qui utilise le langage Rego pour définir et appliquer des règles de sécurité, compliance et autorisation à travers toute la stack.",
      "difficulty": "advanced"
    },
    {
      "id": 64,
      "question": "Comment fonctionne l'architecture OPA et où se place-t-elle ?",
      "options": [
        "OPA remplace l'application",
        "OPA est un sidecar/service qui prend des décisions de policy en évaluant des règles Rego contre des données/context",
        "OPA est une base de données",
        "OPA est un load balancer"
      ],
      "answer": 1,
      "explanation": "OPA se déploie comme sidecar ou service. L'application envoie une requête (input) à OPA, qui évalue les règles Rego avec les données (policies, context) et retourne une décision (allow/deny + metadata).",
      "difficulty": "advanced"
    },
    {
      "id": 65,
      "question": "Qu'est-ce que Kyverno pour Kubernetes ?",
      "options": [
        "Un outil de déploiement",
        "Un policy engine natif K8s utilisant du YAML pour valider, muter et générer des ressources",
        "Un service mesh",
        "Un outil de monitoring"
      ],
      "answer": 1,
      "explanation": "Kyverno est un policy engine Kubernetes-natif qui utilise des Custom Resources YAML (pas de nouveau langage). Il peut valider (bloquer), muter (modifier), et générer des ressources K8s.",
      "difficulty": "advanced"
    },
    {
      "id": 66,
      "question": "Quelles sont les stratégies pour automatiser la rotation des secrets ?",
      "options": [
        "La rotation manuelle est suffisante",
        "Dynamic secrets (Vault), rotation schedulée (AWS Lambda), versioning multi-actif, blue-green secret deployment",
        "Ne jamais faire de rotation",
        "Rotation annuelle uniquement"
      ],
      "answer": 1,
      "explanation": "Stratégies d'automatisation : 1) Dynamic secrets (Vault génère à la demande), 2) Rotation schedulée (Lambda/cron), 3) Versioning (activer nouvelle version avant de désactiver l'ancienne), 4) Blue-green deployment des secrets.",
      "difficulty": "advanced"
    },
    {
      "id": 67,
      "question": "Comment réaliser une rotation zero-downtime des secrets ?",
      "options": [
        "Arrêter l'application, changer le secret, redémarrer",
        "Multi-version active : activer le nouveau secret avant de révoquer l'ancien, avec graceful transition",
        "Ce n'est pas possible",
        "Changer uniquement la nuit"
      ],
      "answer": 1,
      "explanation": "Zero-downtime rotation : 1) Créer nouvelle version du secret, 2) Déployer le nouveau secret (apps supportent les deux), 3) Attendre propagation, 4) Révoquer l'ancien. Nécessite versioning et support applicatif.",
      "difficulty": "advanced"
    },
    {
      "id": 68,
      "question": "Que sont les CIS Benchmarks ?",
      "options": [
        "Un outil de performance",
        "Des standards de configuration sécurisée (hardening) par le Center for Internet Security",
        "Un protocole réseau",
        "Un langage de programmation"
      ],
      "answer": 1,
      "explanation": "Les CIS Benchmarks sont des best practices de configuration sécurisée (hardening) développées par la communauté pour OS, cloud, containers, databases, etc. Largement utilisés pour la compliance.",
      "difficulty": "advanced"
    },
    {
      "id": 69,
      "question": "Comment automatiser la compliance SOC 2 dans une infrastructure DevOps ?",
      "options": [
        "Audit manuel annuel uniquement",
        "IaC scanné (tfsec/checkov), audit logs centralisés, RBAC strict, encryption everywhere, automated testing",
        "SOC 2 n'est pas automatisable",
        "Documentation manuelle suffit"
      ],
      "answer": 1,
      "explanation": "Automatisation SOC 2 : IaC scanné pour compliance, audit logs immutables (SIEM), contrôles d'accès automatisés (RBAC), encryption at rest/in transit par défaut, tests automatisés des contrôles, evidence collection automatique.",
      "difficulty": "advanced"
    },
    {
      "id": 70,
      "question": "Pourquoi l'infrastructure immutable aide-t-elle la compliance ?",
      "options": [
        "C'est juste une tendance",
        "Élimine la drift, garantit la reproductibilité, facilite l'audit et la traçabilité des changements",
        "Ce n'est pas lié à la compliance",
        "C'est plus compliqué"
      ],
      "answer": 1,
      "explanation": "Infrastructure immutable (never modified, always replaced) élimine la configuration drift, garantit que la prod correspond exactement au testé, facilite l'audit (changements = code versionné), et simplifie la démonstration de compliance.",
      "difficulty": "advanced"
    }
  ]
}